https://pta.patest.cn/pta/test/15/exam/4/question/719

#include<iostream>
#define Infinity 99999
using namespace std;

typedef struct Pnode *Point;
struct Pnode {
	int n, time;
	Point next;
};

typedef struct Lnode *List;
struct Lnode {
	int n, indegree;
	Point next;
};

typedef struct Tnode *Time;
struct Tnode {
	int earliest, latest;
};

void InsertNode(List l)
{
	int i, j, time;
	cin >> i >> j >> time;
	Point p = new struct Pnode;
	p->n = j - 1;
	p->time = time;
	p->next = l[i - 1].next;
	l[i - 1].next = p;
	l[j - 1].indegree++;
}

List Initialize(int N, int M)
{
	List l = new struct Lnode[N];
	for (int i = 0; i < N; i++)
	{
		l[i].n = i + 1;
		l[i].indegree = 0;
		l[i].next = NULL;
	}
	while (M-- > 0)
		InsertNode(l);
	return l;
}

int GetZeroIndegreeAndCheckCircle(List l, int N)
{
	int i, count = 0;
	for (i = 0; i < N; i++)
	{
		if (l[i].indegree == 0)
			return i;
		else if (l[i].indegree == -1)
			count++;
	}
	if (count == N)
		return N;
	else
		return -1;
}

int ChooseMax(Time time, int N)
{
	int i, max = 0;
	for (i = 0; i < N; i++)
		if (time[i].earliest > max)
			max = time[i].earliest;
	return max;
}

int IsAvailable(List l, int N, Time time)
{
	int zero, result;
	zero = GetZeroIndegreeAndCheckCircle(l, N);
	while (zero != N)
	{
		if (zero == -1)
			return -1;
		l[zero].indegree = -1;
		Point p = l[zero].next;
		while (p != NULL)
		{
			l[p->n].indegree--;
			if (time[p->n].earliest < time[zero].earliest + p->time)
				time[p->n].earliest = time[zero].earliest + p->time;
			p = p->next;
		}
		zero = GetZeroIndegreeAndCheckCircle(l, N);
	}
	result= ChooseMax(time, N);
	return result;
}

void PrintKeyRoutes(List l, int N, Time time)
{
	time[N - 1].latest = time[N - 1].earliest;
	for (int i = N - 1; i >= 0; i--)
	{
		Point p = l[i].next;
		while (p != NULL)
		{
			if (time[p->n].latest - p->time < time[i].latest)
				time[i].latest = time[p->n].latest - p->time;
			p = p->next;
		}
	}
	for (int i = 0; i < N; i++)
	{
		Point p = l[i].next;
		while (p != NULL)
		{
			if (time[i].earliest + p->time == time[p->n].latest)
				cout << i + 1 << "->" << p->n + 1 << endl;
			p = p->next;
		}
	}
}

void DistroyList(List l, int N)
{
	for (int i = 0; i < N; i++)
	{
		Point p = l[i].next;
		while (p != NULL)
		{
			Point t = p;
			p = p->next;
			delete(t);
		}
	}
	delete(l);
}

int main()
{
	int i, N, M, result;
	Time time;
	cin >> N >> M;
	time = new struct Tnode[N];
	for (i = 0; i < N; i++)
	{
		time[i].earliest = 0;
		time[i].latest = Infinity;
	}
	List l = Initialize(N, M);
	result = IsAvailable(l, N, time);
	if (result == -1)
		cout << 0 << endl;
	else
	{
		cout << result << endl;
		PrintKeyRoutes(l, N, time);
	}
	delete(time);
	DistroyList(l, N);
	return 0;
}
